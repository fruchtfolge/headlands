<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>Headlands</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸšœ</text></svg>">
  <!-- <script src="https://cdn.jsdelivr.net/npm/@turf/turf@5.1.6/turf.min.js"></script> -->
  <!-- <script src="https://unpkg.com/jsts/dist/jsts.min.js"></script> -->
  <script src='https://api.mapbox.com/mapbox-gl-js/v1.10.1/mapbox-gl.js'></script>
  <link href='https://api.mapbox.com/mapbox-gl-js/v1.10.1/mapbox-gl.css' rel='stylesheet' />
  <script src='https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-draw/v1.0.9/mapbox-gl-draw.js'></script>
  <link rel='stylesheet' href='https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-draw/v1.0.9/mapbox-gl-draw.css' type='text/css' />
  <!-- <script src="assets/headland.min.js"></script> -->
  <script src="assets/examples.js"></script>
  <style>
      * {
    box-sizing: border-box;
    -moz-box-sizing: border-box;
    -webkit-box-sizing: border-box;
    }

    html,
    body {
      padding: 0px;
      margin: 0px;
      height: 100%;
      width: 100%;
      font-family: Menlo, Monaco, Consolas, "Courier New", monospace;
      color: rgb(38, 38, 38);
      font-size: 12px;
    }

    #jsonWrapper{
      position: absolute;
      background: white;
      outline: 2px solid;
      margin: 20px;
      padding: 20px;
      width: 280px;
    }
    
    #jsonWrapper * {
      margin-bottom: 10px;
    }
    
    #jsonWrapper div {
      margin-bottom: 20px;
    }
    
    #jsonText {
      margin-top: 10px;
      min-height: 70px;
      width: 100%;
      border: none;
      overflow: auto;
      outline: none;
      resize: none;
      -webkit-box-shadow: none;
      -moz-box-shadow: none;
      box-shadow: none;
    }

    #map {
      position: absolute;
      width: 100%;
      height: 100%;
    }
    .slider {
        margin-top: 10px;
        -webkit-appearance: none;
        width: 180px;
        height: 8px;
        border-radius: 5px;
        background: white;
        outline: none;
        opacity: 1;
        -webkit-transition: .2s;
        box-shadow: 0 0 0 1.5pt rgba(0,0,0,0.1);
        transition: opacity .2s;
    }


    .slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: #1abc9c;
        cursor: pointer;
    }

    .slider::-moz-range-thumb {
        width: 15px;
        height: 15px;
        border-radius: 50%;
        background: #1abc9c;
        cursor: pointer;
    }

    .mapboxgl-popup {
      max-width: 200px;
    }

    .mapboxgl-popup-content {
      text-align: center;
    }

    .marker {
      visibility: hidden;
      background-color: rgba(49, 185, 67, 0.51);
      text-align: center;
      color: white;
      line-height: 40px;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      border: 5px solid green;
      cursor: pointer;
    }
    
    .firstUncertain {
      border: 5px solid orange;
      background-color: rgba(200, 143, 46, 0.51);
    }
    
    .lastPoint {
      border: 5px solid blue;
      background-color: rgba(46, 108, 200, 0.51);
    }

    .button {
      -webkit-border-radius: 0;
      -moz-border-radius: 0;
      border-radius: 0px;
      color: #000000;
      font-family: Menlo, Monaco, Consolas, "Courier New", monospace;
      font-size: 12px;
      background: #ffffff;
      padding: 5px 10px 5px 10px;
      border: solid #18191a 2px;
      text-decoration: none;
    }
    
    .link {
      text-decoration: none;
      color: rgba(3, 102, 214, 1);
    }
    
    .link:hover {
      text-decoration: underline;
    }
    
    .button:hover {
      background-color: #f5f5f5;
    }
  </style>
</head>
<body>
  <div id='map'></div>
  <div id="jsonWrapper">
    <h1>Headlands</h1>
    <div>
      This demonstration showcases an algorithm which generates <a class="link" href="https://en.wikipedia.org/wiki/Headland_(agriculture)" target="_blank">headlands</a> for agricultural fields. Each headland identified by the algorithm is shown with a different color. In order to get started, you may click on the <b>Show other example field</b> button, draw a new polygon (button in the top right corner of the map), or paste your own GeoJSON polygon at the bottom of this box.
    </div>
    <div class="buttons">
      <button id="examples" class="button" onclick="getExample()">Show other example field</button>
      <button id="hideDebug" class="button"  onclick="toggleDebug()">Show debug info</button>
    </div>
    <div id="slidecontainer">
      Algorithm settings:
      <br>
      <br>
      <form>
        <label for="turnAngle">Max. turning angle</label>
        <input type="range" min="1" max="90" value="30" class="slider" id="turnAngle" name="turnAngle">
        <output name="angleBubble" for="turnAngle">30Â°</output>
      </form>
      <form>
        <label for="minDist">Min. distance between coordinates</label>
        <input type="range" min="1" max="20" value="10" class="slider second" id="minDist" name="minDist">
        <output name="minDistBubble" for="minDist">10 m</output>
      </form>
      <form>
        <label for="headlandWidth">Headland width</label>
        <input type="range" min="1" max="50" value="12" class="slider second" id="headlandWidth" name="headlandWidth">
        <output name="headlandWidthBubble" for="headlandWidth">12 m</output>
      </form>
    </div>
    <textarea id="jsonText" placeholder="// You may test the algorithm on any valid GeoJSON polygon by pasting it here"></textarea>
  </div>
  
  <script>
    mapboxgl.accessToken = 'pk.eyJ1IjoidG9mZmkiLCJhIjoiY2l3cXRnNHplMDAxcTJ6cWY1YWp5djBtOSJ9.mBYmcCSgNdaRJ1qoHW5KSQ';
    var map = new mapboxgl.Map({
      container: 'map',
      center: [8.727953,52.075006],
      zoom: 16,
      style: 'mapbox://styles/mapbox/satellite-v9?optimize=true',
      customAttribution: '<a href="https://www.ilr.uni-bonn.de/em/em_e.htm" target="_blank">Made with â™¥ by the University of Bonn - EMAS Group</a>'
    });

    var Draw = new MapboxDraw({
      displayControlsDefault: false,
      controls: {
        polygon: true,
        trash: true
      }
    });
    map.addControl(Draw)

    // setup web worker instance
    const worker = new Worker('./assets/worker.js')
    worker.addEventListener('message', e => {
      if (e.data === 'started') { 
        console.log('started');
      } else {
        drawLayer(e.data.polygons,e.data.debug)
      }
    }, false);
    // start worker
    worker.postMessage({ msg: 'start'})
    
    // define some globals
    var block = document.getElementById('jsonText')
    var layers = []
    var markers = []
    var turnAngle = document.getElementById('turnAngle')
    var minCoordDistance = document.getElementById('minDist')
    var headlandWidth = document.getElementById('headlandWidth')
    var turnAngleOutput = document.getElementsByName('angleBubble')[0]
    var minDistOutput = document.getElementsByName('minDistBubble')[0]
    var headlandWidthOutput = document.getElementsByName('headlandWidthBubble')[0]
    var interpolation = false
    var interpolationButton = document.getElementById('interpolation')
    const urlParams = new URLSearchParams(window.location.search);
    var polygon;
    
    block.addEventListener('input', function(e) {
      polygon = JSON.parse(e.target.value);
      if (polygon.geometry.type === "Polygon") {
        addLayer(interpolation);
        map.fitBounds(getBoundingBox(polygon), {padding: {
          left: 340, top: 80, right: 60, bottom: 60
        }})
      }
    })

    map.on('load', function() {
      map.on('draw.create', function (e) {
        polygon = e.features[0]
        addLayer(interpolation);
        Draw.delete(e.features[0].id)
      });
      // parse query parameters (if any)
      const field = urlParams.get('field');
      if (field && !isNaN(Number(field))) {
        getExample(true,Number(field))
      } else {
        getExample(true)
      }  
    });

    turnAngle.addEventListener('input', changeSlider);
    minDist.addEventListener('input', changeSlider);
    headlandWidth.addEventListener('input', changeSlider);
    
    function changeSlider() {
      turnAngleOutput.innerHTML = turnAngle.value +"Â°";
      minDistOutput.innerHTML = minDist.value +" m";
      headlandWidthOutput.innerHTML = headlandWidth.value +" m";
      if (polygon !== undefined) addLayer(interpolation);
    }

    const drawLayer = (polygons,debug) => {
      layers.forEach(layer => {
        map.removeLayer(layer)
      });
      markers.forEach(marker => {
        marker.remove()
      })
      layers = [];
      markers = [];
      Draw.getAll().features.forEach(e => Draw.delete(e.id))
      // const { lineStrings, debug } = headland.lineStrings(polygon, Number(turnAngle.value), Number(minDist.value), { debug: true, interpolate: interpolatePoly })
      // 
      polygons.forEach((geom, i, arr) => {
        // if (i > 4) return
        var id = Math.random().toString(36).substring(7);
        map.addLayer({
          'id': id,
          'type': 'line',
          'source': {
            type: "geojson",
            data: geom
          },
          'layout': {},
          'paint': {
            'line-color': randColor(i,arr.length),
            'line-width': 8
          }
        })
        layers.push(id);
        /*
        geom.geometry.coordinates.forEach((point,j,arr) => {
          if (j === arr.length -1) return
          const el = document.createElement('div');
          el.className = 'marker';
          
          el.innerHTML = i + ',' + j
          const marker1 = new mapboxgl.Marker(el)
            .setLngLat(point)
            .setPopup(new mapboxgl.Popup({ offset: 25 })) // add popups
            .addTo(map);
            markers.push(marker1)
        })
        */
      });
      
      /*
      debug.forEach((point,i) => {
        const el = document.createElement('div');
        el.className = 'marker';
        if (point.type === 'Breakpoint') {
          el.className = 'marker lastPoint';
        } else if (point.type?.includes('Below')) {
          el.className = 'marker firstUncertain';
        }
        
        el.innerHTML = i
        const marker1 = new mapboxgl.Marker(el)
          .setLngLat(point.coord)
          .setPopup(new mapboxgl.Popup({ offset: 25 }) // add popups
          .setHTML('<h3>' + point.type + '</h3><p>' + 
           'Angle to last coordinate exceeding the min. distance: ' + point.angle + '<br>' +
           'Reference angle: ' + point.refAngle + '<br>' +
           'Angle difference (between cur. angle and reference): ' + point.angleDiff + '<br>' +
           'Distance: ' + point.distance + '<br>' +
           'Index of last point: ' + point.lastPointIndex + '<br>' +
           '</p>'))
          .addTo(map);
          markers.push(marker1)
      })
      */
      function randColor(colorNum, colors){
          if (colors < 1) colors = 1; // defaults to one color - avoid divide by zero
          return "hsl(" + (colorNum * (360 / colors) % 360) + ",100%,50%)";
      }

  }
  
  const addLayer = debounce(() => {
    worker.postMessage({
      polygon, 
      maxAngle: Number(turnAngle.value),
      minCoordDistance: Number(minDist.value),
      width: Number(headlandWidth.value),
      debug: true
    })
  }, 150)

  function getExample(onload,no) {
    let number = 60
    if (onload && !no) {
      // polygon = examplePlots[60]
      polygon = examplePlots[number]
      addLayer(interpolation);
    } else if (onload && no) {
      number = no
      polygon = examplePlots[number]
      addLayer(interpolation);
      map.fitBounds(getBoundingBox(polygon), {padding: {
        left: 340, top: 80, right: 60, bottom: 60
      }, duration: 0})
    } else {
      let random = Math.floor(Math.random() * 79)
      // do not consider some examples for now, as they are not 'real' arable fields
      // or just too small 
      const ignoredFields = [33]
      if (ignoredFields.indexOf(random) > -1) random = 0
      number = no ? no : random
      polygon = examplePlots[number]
      console.log(polygon);
      console.log('Example number: ' + number);
      addLayer(interpolation);
      map.fitBounds(getBoundingBox(polygon), {padding: {
        left: 340, top: 80, right: 60, bottom: 60
      }})
    }
    urlParams.set('field',number)
    var pageUrl = '?' + urlParams.toString();
    window.history.pushState('', '', pageUrl)
  }
  
  let markersShown = false;
  let hideDebug = document.getElementById('hideDebug')
  function toggleDebug() {
    markersShown = !markersShown
    let direction = markersShown ? 'visible' : 'hidden';
    if (markersShown) hideDebug.innerHTML = 'Hide debug info'
    else hideDebug.innerHTML = 'Show debug info'
    for (let el of document.querySelectorAll('.marker')) el.style.visibility = direction;
  }
  function debounce(func, wait, immediate) {
  	var timeout;
  	return function() {
  		var context = this, args = arguments;
  		var later = function() {
  			timeout = null;
  			if (!immediate) func.apply(context, args);
  		};
  		var callNow = immediate && !timeout;
  		clearTimeout(timeout);
  		timeout = setTimeout(later, wait);
  		if (callNow) func.apply(context, args);
  	};
  }
  function getBoundingBox(data) {
  var bounds = {}, coordinates, point, latitude, longitude;

    coordinates = data.geometry.coordinates;

    if(coordinates.length === 1){
      // It's only a single Polygon
      // For each individual coordinate in this feature's coordinates...
      for (var j = 0; j < coordinates[0].length; j++) {
        longitude = coordinates[0][j][0];
        latitude  = coordinates[0][j][1];

        // Update the bounds recursively by comparing the current xMin/xMax and yMin/yMax with the current coordinate
        bounds.xMin = bounds.xMin < longitude ? bounds.xMin : longitude;
        bounds.xMax = bounds.xMax > longitude ? bounds.xMax : longitude;
        bounds.yMin = bounds.yMin < latitude ? bounds.yMin : latitude;
        bounds.yMax = bounds.yMax > latitude ? bounds.yMax : latitude;
      }
    } else {
      // It's a MultiPolygon
      // Loop through each coordinate set
      for (var j = 0; j < coordinates.length; j++) {
        // For each individual coordinate in this coordinate set...
        for (var k = 0; k < coordinates[j][0].length; k++) {
          longitude = coordinates[j][0][k][0];
          latitude  = coordinates[j][0][k][1];

          // Update the bounds recursively by comparing the current xMin/xMax and yMin/yMax with the current coordinate
          bounds.xMin = bounds.xMin < longitude ? bounds.xMin : longitude;
          bounds.xMax = bounds.xMax > longitude ? bounds.xMax : longitude;
          bounds.yMin = bounds.yMin < latitude ? bounds.yMin : latitude;
          bounds.yMax = bounds.yMax > latitude ? bounds.yMax : latitude;
        }
      }
    }
  // Returns an object that contains the bounds of this GeoJSON data.
  // The keys describe a box formed by the northwest (xMin, yMin) and southeast (xMax, yMax) coordinates.
  return [bounds.xMin,bounds.yMin,bounds.xMax,bounds.yMax]
}
  </script>
</body>

</html>
